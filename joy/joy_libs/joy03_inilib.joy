(* 
 * This initial library contains a collection of Joy03 operators and combinators that are widely useful. 
 * Most are not dependent on particular types. 
 * Contents
 
 *
 * N.B. All other libraries will ensure that this library is also loaded.
 *
 *)

PUBLIC

_inilib == true;

(* - - - - -  Boolean and Mathematic Operators  - - - - *)

    pred == 1 -;
    succ == 1 +;


(* - - - - - Stack Manipulation Operators  - - - - *)


    # c++ core performance built-ins:
    # dup
    # dupd
    # pop
    # popd
    # pop2
    # unit
    # swap
    # swapd
    # rotate
    # rollup
    # rolldown


(* - - - - - List Operators  - - - - *)

    swons   == swap cons;   # A X -> B where aggregate B is A with a new member X (first member for sequences).
   
    unswons == uncons swap; # A -> R F where R and F are the rest and the first of non-empty aggregate A.

    first   == uncons pop;  # A -> F where F is the first member of the non-empty aggregate A.
    rest    == unswons pop; # A -> R where R is the non-empty aggregate A with its first member removed.

    # shunt is actually extra to joy03 but useful here
    shunt == [swons] step;   # [a b] [f] g|shunt   ->  |a f g b f g
    # presented in "Atomic Programs of Joy" by Manfred von Thun - but not in joy03 manual
    swoncat == reverse shunt; # concatenates two sequences of the same type, it appends the second parameter to the top parameter.
    concat  == swap swoncat; # does the same except that it executes a swap first.

(* - - - - - General Combinators  - - - - *)

    # c++ core performance built-ins:
    # i == stack rest swap infra unstack
    # dip == stack rest rest swap infra cons unstack
    # step
    # times
    # reverse

    # joy03
    nullary == stack rest swap infra first; # [P] -> R Executes P, which leaves R on top of the stack. No matter how many parameters this consumes, none are removed from the stack.b
    unary == stack rest swap infra first popd; # X [P] -> R Executes P, which leaves R on top of the stack. No matter how many parameters this consumes, exactly one is removed from the stack
    branch == choice i; # B [T] [F] -> T/F If B is true, then executes T else executes F.

    # presented in "Atomic Programs of Joy" by Manfred von Thun - but not in joy03 manual
    # The dipd and the dipddcombinator are similar. They expect two or three elements, (X) and (Y), or (X), (Y) and (Z) below the quotation. The two or three elements are saved and restored after the execution of the quotation.
    dipd    == [dip] cons dip;
    dipdd   == [dipd] cons dip;
    b == [i] dip i; # The b combinator expects two quotations [P] and [Q], with [Q] on top. It removes the two quotations and executes first [P] and then [Q].
    cleave == [nullary] dip swap [nullary] dip swap; # a [f] [g]|cleave   ->  |a f a g
    # equal
    # drop
    # take
    # at
    # of
    
    
    # joy03
    ifte == [ [stack] dip infra first ] dipd branch; #[B] [T] [F] -> ... Executes B. If that yields true, then executes T else executes F.
    app1 == i; # 	X [P] -> R Executes P, pushes result R on stack without X.
    app2 == dup rollup i [i] dip; # Obsolescent. == unary2
    app3 == dup rollup i [app2] dip; # Obsolescent. == unary3

    fold == swapd step; # [a b ...] i [f]|fold  ->   [f/i,a b ...]|

(* - - - - - List Operators  needing Combinators above- - - - *)

    # null ( TODO: need list op ) 


(* - - - - - IO Operators  - - - - *)

    BEL == '\007;   # bell
    BS == BEL succ; # backspace [\b]
    HT == BS succ;  # horizontal tab [\t]
    LF == HT succ;  # line feed [\n]
    VT == LF succ;  # vertical tab
    FF == VT succ;  # form feed [\f]
    CR == FF succ;  # carriage return [\r]
    
    putchars == [putch] step;

"joy03_inilib is loaded" putchars LF putch.

"joy_libs/extra_inilib.joy" include.