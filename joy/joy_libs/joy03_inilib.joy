(* 
 * This initial library contains a collection of Joy03 operators and combinators that are widely useful. 
 * Most are not dependent on particular types. 
 * Contents
 
 *
 * N.B. All other libraries will ensure that this library is also loaded.
 *
 *)

PUBLIC

_inilib == true;


(* - - - - - Stack Manipulation Operators  - - - - *)


    # c++ core performance built-ins:
    # dup
    # dupd
    # pop
    # popd
    # pop2
    # unit
    # swap
    # swapd
    # rotate
    # rollup
    # rolldown

    dup2 == dup [[dup]dip swap] dip;


(* - - - - - List Operators  - - - - *)

    swons   == swap cons;   # A X -> B where aggregate B is A with a new member X (first member for sequences).
   
    unswons == uncons swap; # A -> R F where R and F are the rest and the first of non-empty aggregate A.

    first   == uncons pop;  # A -> F where F is the first member of the non-empty aggregate A.
    rest    == unswons pop; # A -> R where R is the non-empty aggregate A with its first member removed.

    (*
     * presented in "Programming In Joy" By Manfred von Thun - but not in joy03 manual
     * The shunt operator takes two sequences as parameters and, starting at the front of the topmost parameter, moves all items onto the front of the second parameter.
     *)
    shunt == [swons] step;   # [a b] [f] g|shunt   ->  |a f g b f g
    (*
     * presented in "Atomic Programs of Joy" by Manfred von Thun - but not in joy03 manual
     * swoncat concatenates two sequences of the same type, it appends the second parameter to the top parameter.
     * concat  does the same except that it executes a swap first.
     *) 
    swoncat == reverse shunt; 
    concat  == swap swoncat;

(* - - - - - General Combinators  - - - - *)

    # c++ core performance built-ins:
    # i == stack rest swap infra unstack
    # dip == stack rest rest swap infra cons unstack
    # step
    # times
    # reverse

    # joy03
    nullary == stack rest swap infra first; # [P] -> R Executes P, which leaves R on top of the stack. No matter how many parameters this consumes, none are removed from the stack.b
    unary == stack rest swap infra first popd; # X [P] -> R Executes P, which leaves R on top of the stack. No matter how many parameters this consumes, exactly one is removed from the stack
    branch == choice i; # B [T] [F] -> T/F If B is true, then executes T else executes F.


    (*
     * presented in "Atomic Programs of Joy" by Manfred von Thun - but not in joy03 manual
     * The dipd and the dipdd combinator are similar. They expect two or three elements, (X) and (Y), or (X), (Y) and (Z) below the quotation. The two or three elements are saved and restored after the execution of the quotation.
     *)    
    dipd    == [dip] cons dip;
    dipdd   == [dipd] cons dip;
    b == [i] dip i; # The b combinator expects two quotations [P] and [Q], with [Q] on top. It removes the two quotations and executes first [P] and then [Q].
    cleave == [nullary] dip swap [nullary] dip swap; # a [f] [g]|cleave   ->  |a f a g
    # equal
    # drop
    # take
    # at
    # of

    (* 
     * presented in "Mathematical foundations of Joy" by Manfred von Thun - but not in joy03 manual
     * The names of these combinators have been chosen because of their similarity to the K combinator, W combinator and the C combinator in combinatory logic.
     *)
        k   ==   [pop]  dip  i;
        w   ==   [dup]  dip  i;
        c   ==   [swap] dip  i;
    
    # joy03
    ifte == [ [stack] dip infra first ] dipd branch; #[B] [T] [F] -> ... Executes B. If that yields true, then executes T else executes F.
    app1 == i; # 	X [P] -> R Executes P, pushes result R on stack without X.
    app2 == dup rollup i [i] dip; # Obsolescent. == unary2
    app3 == dup rollup i [app2] dip; # Obsolescent. == unary3

    fold == swapd step; # [a b ...] i [f]|fold  ->   [f/i,a b ...]|

(* -----Boolean and Mathematic Operators ---- *)

    pred == 1 - ;
    succ == 1 + ;
    or   ==[pop true][id] branch;
    and == [id][pop false] branch;
    not == false true choice;
    xor == dup2 or rollup and not and;
    max == dup2 > rollup choice;
    min == dup2 < rollup choice;

(* -----List Operators  needing Combinators above ---- *)

    # zip
    sum == 0.0 swap[+] step;
    product == 1.0 swap[*] step;
    #destructive size == 0.0 swap[pop succ] step;
    second == rest first;
    third == rest second;
    quote == [] cons;
    leaf == list not;
    # null

(* - - - - - IO Operators  - - - - *)

    BEL == '\007;   # bell
    BS == '\008;    # backspace [\b]
    HT == 9 chr;  # horizontal tab [\t]
    LF == 10 chr;  # line feed [\n]
    VT == 11 chr;  # vertical tab
    FF == 12 chr;  # form feed [\f]
    CR == 13 chr;  # carriage return [\r]
    
    putchars == [putch] step;

"joy03_inilib is loaded" putchars LF putch.

"joy_libs/extra_inilib.joy" include.
